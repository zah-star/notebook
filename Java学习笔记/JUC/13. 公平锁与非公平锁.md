公平锁: 是指多个线程按照申请锁的顺序来获取锁, 举例: 
`Lock lock = new ReentrantLock(true);`

非公平锁: 是指多个线程获取锁的顺序并不是按照申请锁的顺序, 有可能后申请的线程比先申请的线程优先获取锁, 在高并发环境下, 有可能造成优先级翻转或者饥饿的状态(某个线程一直得不到锁), 举例:
`Lock lock = new ReentrantLock(true);`
`Lock lock = new ReentrantLock();`


### 公平锁与非公平锁的原理

为什么synchronized是非公平锁还是随机锁, 公平, 非公平, 随机的区别

[[AQS|AQS]]


### 为什么[[ReentrantLock类|ReentrantLock]]默认使用非公平锁

1. 恢复挂起的线程到真正锁的获取还是有时间差的, 从开发人员来看这个时间微乎其微, 但是从CPU的角度来看, CPU空闲状态时间
2. 使用多线程很重要的考量点是线程切换的开县, 当采用非公平锁时, 当1一个线程请求锁获取同步状态, 然后释放同步状态, 所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大, 所以就减少了线程的开销. 


### 什么时候用公平锁, 什么时候用非公平锁

如果为了更高的吞吐量, 很显然非公平锁是比较合适的, 因为节省很多线程切换时间, 吞吐量自然就上去了; 否则就用公平锁, 大家公平使用.
