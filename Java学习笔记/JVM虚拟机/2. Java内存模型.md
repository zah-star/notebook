>《Java虚拟机规范》中曾试图定义一种“Java内存模型”(Java Memory Model, JMM)来屏蔽各种硬件和操作系统的内存访问差异, 以实现让Java程序在各种平台下都能达到一致的内存访问效果. 在此之前, 主流程序语言(如C和C++等)直接使用物理硬件和操作系统的内存模型. 因此, 由于不同平台上内存模型的差异, 有可能导致程序在一套平台上并发完全正常, 而在另外一套平台上并发访问却经常出错, 所以在某些场景下必须针对不同的平台来编写程序.
>
>定义Java内存模型并非一件容易的事, 这个模型必须定义得足够严谨, 才能让Java的并发内存访问操作不会产生歧义; 但是也必须定义得足够宽松, 使得虚拟机的实现能够有足够的自由空间去利用硬件的各种特性(寄存器, 高速缓存和指令集中某些特有的指令)来获取更好的执行速度. 经过长时间的验证和修补, 直到JDK5(实现了JSR-133)发布后, Java内存模型才终于成熟, 完善起来了.
>
>摘自《深入理解Java虚拟机》


### 三大特性
1. 可见性
是指当一个线程修改了某一个共享变量的值, 其他线程是否能够立即知道该变更.

2. 原子性
是指一个操作是不可打断的, 即多线程环境下, 操作不能被其他线程干扰

3. 有序性



### 多线程先行发生原则之happens-before
总原则:
1. 如果一个操作happens-before另一个操作, 那么第一个操作的执行结果将对第二个操作可见, 而且第一个操作的执行顺序排在第二个操作之前.
2. 两个操作之间存在happens-before关系, 并不意味着一定要按照happens-before原则制定的顺序来执行, 如果重排序之后的执行结果与按照happens-before关系来执行的结果一致, 那么这种重排序并不非法.


8条具体原则:
1. 次序规则: 一个线程内, 按照代码的顺序, 写在前面的操作先行发生于写在后面的操作;
2. 锁定规则: 一个`unlock`操作先行发生于后面(这里的'后面'指时间上的先后)对同一个锁的lock操作;
3. [[3. volatile|volatitle]]变量规则: 对一个`volatile`操作的写操作先行发生于后面对这个变量的读操作, 前面的写对后面的读是可见的, 这里的"后面"同样是指时间上的先后;
4. 传递规则: 如果操作A先行发生于B, 而操作B又先行发生于C, 则可以得出操作A先行发生于操作C;
5. 线程启动规则: `Thread`对象的[[1. start()方法|start()]]方法先行发生于此线程的每一个动作
6. 线程中断规则: 对线程[[21. 3大中断方法说明|interrupt()]]方法的调用先行发生于被中断线程的代码检测到中断事件的发生;
7. 线程终止规则: 线程中的所有操作都先行发生于对此线程的终止检测, 我们可以通过`isAlive()`等手段检测线程是否已经终止执行;
8. 对象终结规则: 一个对象的初始化完成(构造函数执行结束)先行发生于它的[[`finalize()`|finalize()]]方法的开始